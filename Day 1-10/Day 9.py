# -*- coding: utf-8 -*-
"""Day 9

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/181tVOuJdk0a-mSpRgnBoJwT7ybCv1Hrp

# **CHALLENGE DAY 9**

# Task 1

It is commonly said that one human year is equivalent to 7 dog years.

However this simple conversion fails to recognize that dogs reach adulthood in approximately two years.

As a result, some people believe that it is better to count each of the first two human years as 10.5 dog years, and then count each additional human year as 4 dog years.

Write a program that implements the conversion from human years to dog years described in the previous paragraph. Ensure that your program works correctly for conversions of less than two human years and for conversions of two or more human years.

Your program should display an appropriate error message if the user enters a negative number.
"""

#using try/except to filter out invalid input and returning an error message
try:
  human_year = int(input("Please enter the number of years:")) #asking user to enter input

#defining the function to solve the given task based on the instructions
  def dog_year(human_year):
    if human_year < 0: #condition for a negative entry
      return "Please enter a valid number of years" 
    elif human_year == 0: #condition for entry as 0
      return "0 dog year"
    elif human_year <= 2: #condition for the first two years
      return str(10.5 * human_year) + " dog years"
    else: #condition for more than two years
      return str(21 + (4 * (human_year - 2))) + " dog years"

  print(dog_year(human_year))

except ValueError:
  print("Please enter a valid input")

"""# Task 2

One of the first known examples of encryption was used by Julius Caesar.

Caesar needed to provide written instructions to his generals, but he didnâ€™t want his enemies to learn his plans if the message slipped into their hands.
As result, he developed what later became known as the Caesar Cipher.

The idea behind this cipher is simple (and as a result, it provides no protection against modern code breaking techniques).

Each letter in the original message is shifted by 3 places.

As a result, A becomes D, B becomes E, C becomes F, D becomes G, etc. The last three letters in the alphabet are wrapped around to the beginning: X becomes A, Y becomes B and Z becomes C.

Non-letter characters are not modified by the cipher.

Write a program that implements a Caesar cipher.

Allow the user to supply the message and the shift amount, and then display the shifted message.

Ensure that your program encodes both uppercase and lowercase letters.

Your program should also support negative shift values so that it can be used both to encode messages and decode messages.
"""

#asking user to enter input
original_message = input("Please enter your code message: ")
shift_amount = int(input("Please enter by how much value the message should be shifted: "))

new_message = ""   #initialising new message as an empty string

#using loop to change each character according to the shift number
for ch in original_message:
  if ch >= "a" and ch <= "z": #conditioning for lowercase
    pos = ord(ch) - ord("a")  #getting the numerical position 
    new_pos = (pos + shift_amount) % 26 #getting the new position by adding the shift amount, and using modulus function to re-initialize it
    new_character = chr(new_pos + ord("a")) #changing back to character
    new_message = new_message + new_character #appending to the new message
  elif ch >= "A" and ch <= "Z":  #conditioning for uppercase
    pos = ord(ch) - ord("A")  #getting the numerical position 
    new_pos = (pos + shift_amount) % 26  #getting the new position by adding the shift amount, and using modulus function to re-initialize it
    new_character = chr(new_pos + ord("A"))  #changing back to character
    new_message = new_message + new_character  #appending to the new message
  else:  #conditioning for non-alphabets
    new_message = new_message + ch  #simply adding it in as instructed

print("The Caeser cipher of this message is ", new_message)
